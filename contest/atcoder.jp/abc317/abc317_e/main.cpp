#include <bits/stdc++.h>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n)-1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n)-1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;

const int64_t inf = 1e18;

// 方向（左上始点）
const string direction = "^v<>";
const vector<int> dx = {0, 0, -1, 1};
const vector<int> dy = {-1, 1, 0, 0};

string obstacle = direction + "#";

int64_t solve(int H, int W, vector<vector<char>> &A)
{
    pair<int, int> start, goal;

    // 視線に入る部分を壁とする
    REP3(i, 1, A.size() - 1)
    {
        REP3(j, 1, A[0].size() - 1)
        {
            // スタート地点を記録しておく
            if (A[i][j] == 'S')
            {
                start = {i, j};
            }
            // ゴール地点を記録しておく
            if (A[i][j] == 'G')
            {
                goal = {i, j};
            }

            REP(k, 4)
            {
                if (A[i][j] == direction[k])
                {
                    auto x = j, y = i;
                    while (true)
                    {
                        x += dx[k];
                        y += dy[k];
                        if (obstacle.find(A[y][x]) != string::npos)
                        {
                            break;
                        }
                        A[y][x] = '!';
                    }
                }
            }
        }
    }
    obstacle += "!";

    // スタート地点から経路探索
    vector<vector<int64_t>> distance(A.size(), vector<int64_t>(A[0].size(), -1));
    queue<pair<int, int>> Q;
    auto query_push = [&](int i, int j, int d)
    {
        if (distance[i][j] == -1)
        {
            distance[i][j] = d;
            Q.emplace(i, j);
        }
    };
    query_push(start.first, start.second, 0);

    while (!Q.empty())
    {
        auto [i, j] = Q.front();
        Q.pop();
        REP(k, 4)
        {
            auto x = j + dx[k];
            auto y = i + dy[k];
            if (obstacle.find(A[y][x]) != string::npos)
            {
                continue;
            }
            query_push(y, x, distance[i][j] + 1);
        }
    }

    return distance[goal.first][goal.second];
}

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int H, W;
    std::cin >> H >> W;
    vector<vector<char>> A(H + 2, vector<char>(W + 2, '#'));
    REP3(i, 1, H + 1)
    {
        REP3(j, 1, W + 1)
        {
            std::cin >> A[i][j];
        }
    }
    auto ans = solve(H, W, A);
    std::cout << ans << '\n';
    return 0;
}
