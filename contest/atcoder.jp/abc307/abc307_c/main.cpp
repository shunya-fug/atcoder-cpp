#include <bits/stdc++.h>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n)-1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n)-1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;

const std::string YES = "Yes";
const std::string NO = "No";
bool solve(int H_A, int W_A, int H_B, int W_B, int H_X, int W_X, const std::vector<string> &A, const std::vector<string> &B, const std::vector<string> &X)
{
    int64_t black_X = 0;
    for (auto x : X)
    {
        for (auto c : x)
        {
            if (c == '#')
            {
                black_X++;
            }
        }
    }

    vector<string> C(20, string(20, '.'));
    // vector<string> C(max((H_A - 1) * 2 + H_B, H_X), string(max((W_A - 1) * 2 + W_B, W_X), '.'));
    REP(i_A, C.size() - H_A)
    REP(j_A, C.front().size() - W_A)
    {
        REP(i_B, C.size() - H_B)
        REP(j_B, C.front().size() - W_B)
        {
            // 初期化
            REP(i, C.size())
            {
                ranges::fill(C[i], '.');
            }

            // シートAを貼り付ける
            REP(i, H_A)
            REP(j, W_A)
            {
                if (A[i][j] == '#')
                {
                    C[i_A + i][j_A + j] = A[i][j];
                }
            }
            // シートBを貼り付ける
            REP(i, H_B)
            REP(j, W_B)
            {
                if (B[i][j] == '#')
                {
                    C[i_B + i][j_B + j] = B[i][j];
                }
            }

            // シートの黒いマスを数える
            int64_t black = 0;
            for (auto row : C)
            {
                for (auto c : row)
                {
                    if (c == '#')
                    {
                        black++;
                    }
                }
            }
            // シートA,Bの全ての黒いマスを使ってシートXが作れるかどうか
            if (black != black_X)
            {
                continue;
            }

            // 条件に一致しているかどうか
            REP(i_X, C.size() - H_X)
            REP(j_X, C.front().size() - W_X)
            {
                REP(i, H_X)
                REP(j, W_X)
                {
                    // 条件に一致しない場合は次のループへ
                    if (C[i_X + i][j_X + j] != X[i][j])
                    {
                        goto NEXT_LOOP;
                    }
                }
                return true;
            NEXT_LOOP:
                continue;
            }
        }
    }
    return false;
}

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int H_A, W_A;
    std::cin >> H_A >> W_A;
    std::vector<string> A(H_A);
    REP(i, H_A)
    {
        std::cin >> A[i];
    }
    int H_B, W_B;
    std::cin >> H_B >> W_B;
    std::vector<string> B(H_B);
    REP(i, H_B)
    {
        cin >> B[i];
    }
    int H_X, W_X;
    std::cin >> H_X >> W_X;
    std::vector<string> X(H_X);
    REP(i, H_X)
    {
        cin >> X[i];
    }
    auto ans = solve(H_A, W_A, H_B, W_B, H_X, W_X, A, B, X);
    std::cout << (ans ? YES : NO) << '\n';
    return 0;
}
