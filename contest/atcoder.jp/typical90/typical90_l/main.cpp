#include <bits/stdc++.h>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n)-1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n)-1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;
#include <atcoder/dsu>

const std::string YES = "Yes";
const std::string NO = "No";
const vector<int> dx = {0, 0, -1, 1};
const vector<int> dy = {-1, 1, 0, 0};
vector<bool> solve(auto H, auto W, /*auto Q,*/ const std::vector<vector<pair<int64_t, int64_t>>> &q)
{
    vector<vector<bool>> board(H, vector<bool>(W, false));
    atcoder::dsu d(H * W);
    vector<bool> ans;
    REP(i, q.size())
    {
        switch (q[i].size())
        {
        case 1:
        {
            auto [y, x] = q[i][0];
            board[y][x] = true;
            REP(j, dx.size())
            {
                auto ny = y + dy[j], nx = x + dx[j];
                if (0 <= nx and nx < W and 0 <= ny and ny < H and board[ny][nx])
                {
                    d.merge(W * y + x, W * ny + nx);
                }
            }
        }
        break;
        case 2:
        {
            auto [y1, x1] = q[i][0];
            auto [y2, x2] = q[i][1];
            ans.push_back(board[y1][x1] and board[y2][x2] and d.same(W * y1 + x1, W * y2 + x2));
        }
        break;
        }
    }
    return ans;
}

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int64_t H, W, Q;
    std::cin >> H >> W >> Q;
    std::vector<vector<pair<int64_t, int64_t>>> q(Q);
    REP(i, Q)
    {
        int64_t t;
        std::cin >> t;
        REP(j, t)
        {
            int64_t r, c;
            cin >> r >> c;
            q[i].push_back({r - 1, c - 1});
        }
    }
    for (bool ans : solve(H, W, q))
    {
        std::cout << (ans ? YES : NO) << '\n';
    }
    return 0;
}
